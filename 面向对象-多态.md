# 面向对象-多态

### 1.基本概念

静态： 函数重载，运算符重载。（提前确定函数地址）

动态多态：派生类，虚函数。（运行阶段才确定函数地址）

 

```c++
virtual void speak()
{
    cout << "虚函数，地址晚绑定" << endl;
}
//把子类对象传入父类的过程中，动态的输出子类同名函数的结果
//ex: 父类animal, 子类cat,dog，没使用 virtual的时候，输出的是animal类的speak
//使用后输出的是传入的子类
void test(Animal &animal)//可以传入cat or dog
{
    animal.speak();
}
```

总结：

多态满足条件：

- 有继承关系
- 子类重写了父类的虚函数

多态使用条件

- 父类指针或引用指向子类的对象

重写：函数返回值类型，函数名，参数列表，完全一致



## 2.多态的底层原理

父类虚函数会生成 vfptr (虚函数指针) - -> vftable (虚函数地址表) 的入口地址。

子类也一样，当父类的引用指向子类的对象后，会去找子类的虚函数表。



优点：组织结构清晰，可读性强



### 3.纯虚函数和抽象类

```c++
//纯虚函数
virtual void func() = 0;
//抽象类：有纯虚函数的类,无法实例化对象
//子类必须重写纯虚函数，否则也无法实例化对象
```



### 4.虚析构和春虚析构

多态使用时，子类中有属性开辟到堆区，那么父类指针在释放时无法调用子类的析构代码。

有虚析构也是抽象类，不能实例化

父类的指针在析构的时候，不会调用子类的析构

```c++
virtual ~func() = 0; //纯虚析构】
//纯虚析构必须要代码实现
func::~func()
{
    //这里是实现
}
```

